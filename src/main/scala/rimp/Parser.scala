package rimp

import scala.collection.mutable

/**
 * A class that includes implementation of functions which
 * parses tokens generated by the lexer and creates an abstract syntax
 * tree representing the program code. The code used in this
 * class is developed from the source code given in Compiler and
 * Formal Languages Module at King's College London led by Dr. Christian Urban.
 */
class Parser extends Tokenizer {
  //  --------- RIMP.Parser -------------


  case class ~[+A, +B](x: A, y: B)

  // constraint for the input
  type IsSeq[A] = A => Seq[_]

  type Tokens = Seq[Token]
  type RArray = mutable.Stack[Array[RVar]]

  // counters used to generate unique IDs for while loops and if statements
  var while_count: Int = 0
  var if_count: Int = 0

  /**
   * Generates a unique identifier string for a while loop, by incrementing the counter and
   * appending the current value to a constant prefix "_k".
   *
   * @return A string representing the unique identifier for the while loop.
   */
  def whileID(): String = {
    while_count += 1
    s"_k$while_count"
  }

  /**
   * Generates a unique identifier string for an if statement, by incrementing the counter and
   * appending the current value to a constant prefix "_if".
   *
   * @return A string representing the unique identifier for the if-statement.
   */
  def ifID(): String = {
    if_count += 1
    s"_if$if_count"
  }

  /**
   * An abstract class for parsers that take an input of type I and
   * return a set of pairs (T, I) representing the result of parsing
   * the input.
   *
   * @tparam I The input type, which must be a sequence of some type.
   * @tparam T The output type of the parser.
   */
  abstract class Parser[I: IsSeq, T] {
    def parse(in: I): Set[(T, I)]

    def parse_all(in: I): Set[T] =
      for ((hd, tl) <- parse(in)
           if tl.isEmpty) yield hd
  }


  // parser combinators

  /**
   * A parser that parses sequences of elements of type 'T' followed by elements of type 'S'.
   * The parser uses two sub-parsers 'p' and 'q' to parse the elements of type 'T' and 'S', respectively.
   *
   * @tparam I The input type of the parser.
   * @tparam T The type of the elements parsed by the 'p' parser.
   * @tparam S The type of the elements parsed by the 'q' parser.
   * @param p The parser used to parse the elements of type 'T'.
   * @param q The parser used to parse the elements of type 'S'.
   */
  class SeqParser[I: IsSeq, T, S](p: => Parser[I, T],
                                  q: => Parser[I, S]) extends Parser[I, ~[T, S]] {
    def parse(in: I): Set[(T ~ S, I)] =
      for ((hd1, tl1) <- p.parse(in);
           (hd2, tl2) <- q.parse(tl1)) yield (new ~(hd1, hd2), tl2)
  }

  /**
   * A parser that tries to match the input against two alternative parsers.
   *
   * @tparam I The type of the input sequence.
   * @tparam T The type of the parsed result.
   * @param p The first parser to try.
   * @param q The second parser to try.
   */
  class AltParser[I: IsSeq, T](p: => Parser[I, T],
                               q: => Parser[I, T]) extends Parser[I, T] {
    def parse(in: I): Set[(T, I)] = p.parse(in) ++ q.parse(in)
  }

  /**
   * A parser that applies a given parser to an input sequence and maps its result to a new value.
   *
   * @tparam I The type of the input sequence.
   * @tparam T The type of the parsed value.
   * @tparam S The type of the mapped value.
   * @param p The parser to apply to the input sequence.
   * @param f The mapping function to apply to the parsed value.
   */
  class MapParser[I: IsSeq, T, S](p: => Parser[I, T],
                                  f: T => S) extends Parser[I, S] {
    def parse(in: I): Set[(S, I)] = for ((hd, tl) <- p.parse(in)) yield (f(hd), tl)
  }

  /**
   * A case class that represents a parser for a specific token string.
   *
   * @param sin The token string to parse.
   */
  case class TokenParser(sin: String) extends Parser[Tokens, Token] {

    /**
     * Parses a given input sequence of tokens and returns a set of matching tokens and the remaining tokens.
     *
     * @param in The input sequence of tokens.
     * @return A set of matching tokens and the remaining tokens.
     */
    def parse(in: Tokens): Set[(Token, Tokens)] = in match {
      case T_LBRACK :: tail if sin == "(" => Set((T_LBRACK, tail))
      case T_RBRACK :: tail if sin == ")" => Set((T_RBRACK, tail))
      case T_LSQRB :: tail if sin == "[" => Set((T_LSQRB, tail))
      case T_RSQRB :: tail if sin == "]" => Set((T_RSQRB, tail))
      case T_LPAREN :: tail if sin == "{" => Set((T_LPAREN, tail))
      case T_RPAREN :: tail if sin == "}" => Set((T_RPAREN, tail))
      case T_ID(s) :: tail if s == sin => Set((T_ID(s), tail))
      case T_OP(s) :: tail if s == sin => Set((T_OP(s), tail))
      case T_NUM(n) :: tail if n.toString == sin => Set((T_NUM(n), tail))
      case T_KWD(s) :: tail if s == sin => Set((T_KWD(s), tail))
      case _ => Set()
    }
  }

  /**
   * A parser that matches a comma (",") in a list of tokens.
   * Implements the 'parse' method required by the 'Parser' trait.
   */
  case object CommaParser extends Parser[Tokens, String] {
    /**
     * Attempts to parse a comma from the given input token stream.
     *
     * @param in The input token stream.
     * @return A set of pairs, where each pair contains the matched comma and the remaining tokens.
     *         If the input does not start with a comma, returns an empty set.
     */
    def parse(in: Tokens): Set[(String, Tokens)] = in match {
      case T_COMMA :: tail => Set((",", tail))
      case _ => Set()
    }
  }

  /**
   * A parser that matches a semi-colon (";") in a list of tokens.
   * Implements the 'parse' method required by the 'Parser' trait.
   */
  case object SEMIParser extends Parser[Tokens, String] {
    /**
     * Attempts to parse a semi-colon from the given input token stream.
     *
     * @param in The input token stream.
     * @return A set of pairs, where each pair contains the matched semi-colon and the remaining tokens.
     *         If the input does not start with a semi-colon, returns an empty set.
     */
    def parse(in: Tokens): Set[(String, Tokens)] = in match {
      case T_SEMI :: tail => Set((";", tail))
      case _ => Set()
    }
  }

  /**
   * A parser that matches a bar symbol ("|") in a list of tokens.
   * Implements the 'parse' method required by the 'Parser' trait.
   */
  case object BarParser extends Parser[Tokens, String] {
    /**
     * Attempts to parse a bar symbol from the given input token stream.
     *
     * @param in The input token stream.
     * @return A set of pairs, where each pair contains the matched bar symbol and the remaining tokens.
     *         If the input does not start with a bar symbol, returns an empty set.
     */
    def parse(in: Tokens): Set[(String, Tokens)] = in match {
      case T_BAR :: tail => Set(("|", tail))
      case _ => Set()
    }
  }


  /**
   * A parser that matches and consumes an identifier token from a list of input tokens.
   */
  case object IdParser extends Parser[Tokens, String] {
    /**
     * Attempts to parse an identifier token from the given input tokens.
     *
     * @param in The list of input tokens to parse.
     * @return A set of zero or one tuple(s) containing the matched identifier string and the remaining unparsed tokens.
     */
    def parse(in: Tokens): Set[(String, Tokens)] = in match {
      case T_ID(s) :: tail => Set((s, tail))
      case _ => Set()
    }
  }

  /**
   * A parser that matches a number in a list of tokens.
   * Implements the 'parse' method required by the 'Parser' trait.
   */
  case object NumParser extends Parser[Tokens, Int] {
    /**
     * Attempts to parse a number from the given input token stream.
     *
     * @param in The input token stream.
     * @return A set of pairs, where each pair contains the matched number and the remaining tokens.
     *         If the input does not start with a number, returns an empty set.
     */
    def parse(in: Tokens): Set[(Int, Tokens)] = in match {
      case T_NUM(n) :: tail => Set((n, tail))
      case _ => Set()
    }
  }

  /**
   * Implicit conversion that enables parser string interpolation.
   *
   * @param sc The string context used to create the parser.
   * @return An object with a 'p' method that returns a new TokenParser object.
   */
  implicit def parser_interpolation(sc: StringContext) = new {
    def p(args: Any*): TokenParser = TokenParser(sc.s(args: _*))
  }

  // more convenient syntax for parser combinators
  implicit def ParserOps[I: IsSeq, T](p: Parser[I, T]) = new {
    def ||(q: => Parser[I, T]) = new AltParser[I, T](p, q)
    def ~[S](q: => Parser[I, S]) = new SeqParser[I, T, S](p, q)
    def map[S](f: => T => S) = new MapParser[I, T, S](p, f)
  }

  abstract class Exp
  abstract class Stmt extends Exp
  abstract class AExp extends Exp
  abstract class BExp extends Exp


  type Block = List[Stmt]
  type ArrBlock = Array[AExp]

  case object Skip extends Stmt
  case class If(a: BExp, bl1: Block, bl2: Block, id: String="NONE") extends Stmt
  case class While(b: BExp, bl: Block, id: String="NONE") extends Stmt
  case class Assign(s: String, a: AExp) extends Stmt
  case class AssignArr(id: String, values: Array[AExp]) extends Stmt
  case class AssignNewArrWithSize(id: String, size: AExp) extends Stmt
  case class UpdateArrIndex(id: String, index: AExp, newVal: AExp) extends Stmt

  case class RevAssign(s: String, a: AExp) extends Stmt
  case class RevAssignArr(id: String, values: Array[AExp]) extends Stmt
  case class RevAssignNewArrWithSize(id: String, size: AExp) extends Stmt
  case class RevUpdateArrIndex(id: String, index: AExp, newVal: AExp) extends Stmt

  case class Var(s: String) extends AExp
  case class ArrayVar(id: String, index: AExp) extends AExp
  case class Num(i: Int) extends AExp
  case class Aop(o: String, a1: AExp, a2: AExp) extends AExp

  case class Bop(o: String, a1: AExp, a2: AExp) extends BExp
  case class Not(b: BExp) extends BExp

  // arithmetic expressions
  lazy val AExp: Parser[Tokens, AExp] =
    (Te ~ p"+" ~ AExp).map[AExp] { case x ~ _ ~ z => Aop("+", x, z) } ||
      (Te ~ p"-" ~ AExp).map[AExp] { case x ~ _ ~ z => Aop("-", x, z) } || Te
  lazy val Te: Parser[Tokens, AExp] =
    (Fa ~ p"*" ~ Te).map[AExp] { case x ~ _ ~ z => Aop("*", x, z) } ||
      (Fa ~ p"/" ~ Te).map[AExp] { case x ~ _ ~ z => Aop("/", x, z) } ||
      (Fa ~ p"%" ~ Te).map[AExp] { case x ~ _ ~ z => Aop("%", x, z) } || Fa
  lazy val Fa: Parser[Tokens, AExp] =
    (p"(" ~ AExp ~ p")").map { case _ ~ y ~ _ => y } ||
      (IdParser ~ p"[" ~ AExp ~ p"]").map { case id ~ _ ~ index ~ _ => ArrayVar(id, index) } ||
      (p"!" ~ IdParser).map[AExp]{ case _ ~ x => Var(x) } ||
      NumParser.map(Num)

  lazy val ArrBlock: Parser[Tokens, ArrBlock] =
    (p"[" ~ ArrVals ~ p"]").map { case _ ~ y ~ _ => y }


  lazy val ArrVals: Parser[Tokens, ArrBlock] =
    (AExp ~ CommaParser ~ ArrVals).map[ArrBlock] { case x ~ _ ~ z => x +: z } ||
      AExp.map(x => Array(x))


  // boolean expressions with some simple nesting
  lazy val BExp: Parser[Tokens, BExp] =
    (AExp ~ p"=" ~ AExp).map[BExp] { case x ~ _ ~ z => Bop("=", x, z) } ||
      (AExp ~ p"!=" ~ AExp).map[BExp] { case x ~ _ ~ z => Bop("!=", x, z) } ||
      (AExp ~ p"<" ~ AExp).map[BExp] { case x ~ _ ~ z => Bop("<", x, z) } ||
      (AExp ~ p">" ~ AExp).map[BExp] { case x ~ _ ~ z => Bop(">", x, z) } ||
      (AExp ~ p">=" ~ AExp).map[BExp] { case x ~ _ ~ z => Bop(">=", x, z) } ||
      (AExp ~ p"<=" ~ AExp).map[BExp] { case x ~ _ ~ z => Bop("<=", x, z) } ||
      (p"~" ~ BExp).map[BExp] { case _ ~ x => Not(x) } ||
      (p"(" ~ BExp ~ p")").map[BExp] { case _ ~ x ~ _ => x }


  // a single statement
  lazy val Stmt: Parser[Tokens, Stmt] =
    p"skip".map[Stmt] { _ => Skip } ||
      (IdParser ~ p":=" ~ AExp).map[Stmt] { case x ~ _ ~ z => Assign(x, z) } ||
      (IdParser ~ p":=" ~ ArrBlock).map[Stmt] { case id ~ _ ~ values => AssignArr(id, values) } ||
      (IdParser ~ p":=" ~ BarParser ~ AExp ~ BarParser).map[Stmt] {
        case id ~ _ ~ _ ~ size ~ _  => AssignNewArrWithSize(id, size)} ||
      (IdParser ~ p"[" ~ AExp ~ p"]" ~ p":=" ~ AExp).map[Stmt] {
        case id ~ _ ~ index ~ _ ~ _ ~ newVal => UpdateArrIndex(id, index, newVal)
      } ||
      (p"if" ~ BExp ~ p"then" ~ Block ~ p"else" ~ Block)
        .map[Stmt] { case _ ~ y ~ _ ~ u ~ _ ~ w => If(y, u, w) } ||
      (p"while" ~ BExp ~ p"do" ~ Block).map[Stmt] { case _ ~ y ~ _ ~ w => While(y, w)} ||
      (p"(" ~ Stmt ~ p")").map[Stmt] { case _ ~ x ~ _ => x }

  // statements
  lazy val Stmts: Parser[Tokens, Block] =
    (Stmt ~ SEMIParser ~ Stmts).map[Block] { case x ~ _ ~ z => x :: z } ||
      Stmt.map { s => List(s) }


  // blocks (enclosed in curly braces)
  lazy val Block: Parser[Tokens, Block] =
    (p"{" ~ Stmts ~ p"}").map { case _ ~ y ~ _ => y } ||
      Stmt.map(s => List(s))

  /**
   * Injects unique IDs into while-loops and if-statements in a given list of statements.
   *
   * @param b The list of statements to inject IDs to inspect.
   * @return A list of statements with unique IDs given to while-loops and if-statements.
   */
  def injectIds(b: Block): List[Stmt] = {
    b.map {
      case w: While =>
        val w_id = whileID()
        w.copy(b = w.b, id = w_id, bl = injectIds(w.bl))
      case i: If => i.copy(a = i.a, id = ifID(), bl1 = injectIds(i.bl1), bl2 = injectIds(i.bl2))
      case other => other
    }
  }

  /**
   * Adds variable declarations and assignments to an AST in order to
   * count the number of iterations in while-loops and branches of if-statements,
   * which is used for reverse evaluation.
   *
   * @param input The input AST.
   * @param output An accumulator for the output AST (default is an empty list).
   * @return The output AST with variable declarations and assignments added.
   */
  def addVars(input: Block, output: Block= List()): Block = input match {
    case Nil => output
    case While(b, bl, id) :: tail =>
      val out = output:+Assign(id, Num(0)):+ While(b, addVars(bl) :+ Assign(id, Aop("+", Var(id), Num(1))), id)
      addVars(tail, out)

    case If(b, bl1, bl2, id) :: tail =>
      val out = (Assign(id, Num(0)) ::output) :+ If(b, addVars(bl1):+Assign(id, Num(1)), addVars(bl2):+Assign(id, Num(0)), id)
      addVars(tail, out)
    case hd::tail => addVars(tail, output:+hd)
  }

  /**
   * Parses a program string and returns a list of statements.
   *
   * @param program The program string to parse.
   * @return A list of parsed statements.
   */
  def parse(program: String): List[Stmt]  = {
    val p = Stmts.parse_all(tokenize(program)).head

    // Inject unique IDs to while-loops and if statements.
    val p_with_ids = injectIds(p)

    // Reset the variable counters after each parse.
    resetCounters()
    // Add variable declarations necessary for reverse evaluation, to the statement list.
    addVars(p_with_ids)
  }


  /**
   * Returns the a statement that represents the reverse of the input statement.
   *
   * @param stmt The input statement to reverse.
   * @return The statement representing the reversed of the input statement.
   */
  private def revASTStmt(stmt: Stmt) = stmt match {
    case Assign(s, a) => RevAssign(s, a)
    case AssignArr(id, values) => RevAssignArr(id, values)
    case AssignNewArrWithSize(id, size) => RevAssignNewArrWithSize(id, size)
    case UpdateArrIndex(id, index, newValue) => RevUpdateArrIndex(id, index, newValue)
    case If(_, bl1, bl2, id) =>
      If(Bop("=", Var(id), Num(1)), revAST(bl1), revAST(bl2), id)
    case While(_, bl, id) =>
      While(Bop(">", Var(id), Num(0)), revAST(bl), id)
    case _ => stmt
  }

  /**
   * Returns a reversed version of the given AST.
   *
   * @param stmts  The AST (list of statements) to reverse.
   * @param output An accumulator for the AST (list of statements) generated so far (default is an empty list).
   * @return The reverse version of the input AST.
   */
  def revAST(stmts: List[Stmt], output: List[Stmt] = List()): List[Stmt] = stmts match {
    case Nil => output
    case hd :: tail => revAST(tail, output) :+ revASTStmt(hd)
  }

  /**
   * Converts an Exp object representing a statement to a String containing
   * the equivalent code in RIMP programming language.
   *
   * @param stmt The statement to be converted.
   * @return A String containing the equivalent code in RIMP.
   */
  private def stmt2code(stmt: Exp): String = stmt match {
    case Skip => "skip"
    case If(a, bl1, bl2, if_id) =>
      val ifId = if_id.tail(2)
      s"if-$ifId ${stmt2code(a)} then {\n${bl1.map(x => stmt2code(x)).mkString(";\n")}\n} else {\n${bl2.map(x => stmt2code(x)).mkString(";\n")}\n}"
    case While(b, bl, id) =>
      val whileId = id.tail.tail
      s"\nwhile-$whileId ${stmt2code(b)} do {\n${bl.map(x => stmt2code(x)).mkString(";\n")}\n}"
    case Assign(s, a) => s"$s := ${stmt2code(a)}"
    case AssignArr(id, values) => s"$id := ${values.map(stmt2code).mkString("[", ", ", "]")}"
    case AssignNewArrWithSize(id, size) => s"$id := |${stmt2code(size)}|"
    case UpdateArrIndex(id, index, newVal) => s"$id[${stmt2code(index)}] := ${stmt2code(newVal)}"
    case ArrayVar(id, index) => s"$id[${stmt2code(index)}]"
    case RevAssign(s, a) => s"$s =: ${stmt2code(a)}"
    case RevAssignArr(id, values) => s"$id =: ${values.map(stmt2code).mkString("[", ", ", "]")}"
    case RevAssignNewArrWithSize(id, size) => s"$id =: |${stmt2code(size)}|"
    case RevUpdateArrIndex(id, index, newVal) => s"$id[${stmt2code(index)}] =: ${stmt2code(newVal)}"
    case Var(s) => s"!$s"
    case Num(i) => s"$i"
    case Aop(o, a1, a2) => s"${stmt2code(a1)} $o ${stmt2code(a2)}"
    case Bop(o, a1, a2) => s"(${stmt2code(a1)} $o ${stmt2code(a2)})"
    case Not(b) => s"~${stmt2code(b)}"
  }

  /**
   * Transforms a list of statements in an abstract syntax tree to a list of strings
   * containing the corresponding code.
   *
   * @param ast The list of statements in the abstract syntax tree to transform.
   * @param output An accumulator for the output list of strings (default is an empty list).
   * @return The list of strings containing the corresponding code.
   */
   private def ast2code(ast: List[Stmt], output: List[String] = List()) : List[String] = ast match {
    case Nil => output
    case s::rest =>
      if(rest.isEmpty) {
        stmt2code(s)::ast2code(rest)
      }else {
        s"${stmt2code(s)};\n"::ast2code(rest)
      }
  }

  /**
   * Translates the given code string into new version of RIMP code including the additional
   * variables, identifiers and code snippets which were added to the AST to
   * support reverse evaluation.
   *
   * @param code The code string to translate.
   * @return The translated code string.
   */
  def translate(code: String): String = {
    val ast = parse(code)
    ast2code(ast).mkString.split("\n").filterNot(_.isEmpty).mkString("\n")
  }

  /**
   * Prints reversed representation of the given code.
   *
   * @param code The code string to translate.
   * @return The translated code string.
   */
  def invert(code: String): String = {
    val ast = revAST(parse(code))
    ast2code(ast).mkString.split("\n").filterNot(_.isEmpty).mkString("\n")
  }

  /**
   * Creates a new stack of type RVar and initializes it with the given integer values.
   *
   * @param vars The integer values to push onto the stack.
   * @return A new RVar object containing the given integer values.
   */
  def stack(vars: Int*): RVar = {
    val out = new RVar()
    vars.foreach(x => out.push(x))
    out
  }

  /**
   * Resets while_count and if_count variables to zero.
   */
  def resetCounters(): Unit = {
     while_count = 0
     if_count = 0
  }
}
